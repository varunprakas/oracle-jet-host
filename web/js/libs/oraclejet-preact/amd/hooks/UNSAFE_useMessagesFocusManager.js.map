{"version":3,"file":"UNSAFE_useMessagesFocusManager.js","sources":["../../../src/hooks/UNSAFE_useMessagesFocusManager/useMessagesFocusManager.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { JSX, RefObject } from 'preact';\nimport { useEffect, useMemo, useRef, useState } from 'preact/hooks';\n\nexport type FocusableComponentHandle = {\n  focus: () => boolean;\n  contains: (element: HTMLElement) => boolean;\n};\n\ntype FocusableComponentCallbacks = {\n  onFocus?: () => void;\n};\n\ntype FocusManagerHandlers = Pick<JSX.HTMLAttributes, 'onfocusin' | 'onfocusout' | 'onKeyDown'>;\n\nconst componentsMap = new Map<\n  symbol,\n  [RefObject<FocusableComponentHandle>, FocusableComponentCallbacks?]\n>();\nconst componentsOrder = [] as symbol[];\nconst priorFocusCache = new Map<symbol, Node>();\nlet hasDocumentListener = false;\nlet priorFocusedElement: HTMLElement;\nlet currentFocusedMessage: symbol | undefined;\n\n/**\n * Handles KeyDown event in the document element during the capture phase.\n *\n * @param event The keydown event object\n */\nfunction handleDocumentKeyDownCapture(event: KeyboardEvent) {\n  // Do nothing if any of the following is true:\n  // 1. No components are registered\n  // 2. Pressed key is not F6\n  // 3. Event is defaultPrevented\n  if (componentsMap.size === 0 || event.key !== 'F6' || event.defaultPrevented) {\n    return;\n  }\n\n  // Try cycling focus through the messages and if that fails\n  // set the focus to the prior focused element.\n  if (!cycleFocusThroughMessages(event)) {\n    currentFocusedMessage && togglePreviousFocus(currentFocusedMessage, event);\n  }\n}\n\n/**\n * Handles the blur event captured on the document\n * @param event Blur event object\n */\nfunction handleDocumentBlurCapture(event: FocusEvent) {\n  priorFocusedElement = event.target as HTMLElement;\n}\n\n/**\n * Handles the keydown event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The keydown event object\n */\nfunction handleComponentKeyDown(id: symbol, event: KeyboardEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // Additional checks for keydown event and recognized keys\n  if (event.type === 'keydown' && ['Escape'].includes(event.key)) {\n    // toggle focus to the previously focused element\n    togglePreviousFocus(id, event);\n  }\n}\n\n/**\n * Handles the focus event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The focus event object\n */\nfunction handleComponentFocus(id: symbol, event: FocusEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // Store the id of the current focused message\n  currentFocusedMessage = id;\n\n  // Track previous focus if the priorFocused element is not a part of this or any other\n  // registered component\n  const [, callbacks] = componentsMap.get(id)!;\n  if (priorFocusedElement && !isPartOfRegisteredMessages(priorFocusedElement)) {\n    priorFocusCache.set(id, priorFocusedElement!);\n\n    // since the focus moved to this component from outside, call the\n    // onFocus callbacks if available\n    callbacks?.onFocus?.();\n  }\n}\n\n/**\n * Handles the blur event in the component\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The focus event object\n */\nfunction handleComponentBlur(id: symbol, event: FocusEvent) {\n  // Ignore the call if the comp is not registered anymore or event default is prevented\n  if (!componentsMap.has(id) || event.defaultPrevented) {\n    return;\n  }\n\n  // reset the current focus message ID\n  currentFocusedMessage = undefined;\n}\n\n/**\n * Cycles the focus through the registered messages component from the previous message of current focused\n * message to the top of the hierarchy.\n *\n * @param event The event that initiated this action\n * @returns boolean indicating the result of this action\n */\nfunction cycleFocusThroughMessages(event: Event) {\n  // At this point, we need to focus the previous message from the current focused\n  // message\n  const nextPosition =\n    indexOfOrDefaultTo(componentsOrder, currentFocusedMessage, componentsOrder.length) - 1;\n  for (let i = nextPosition; i > -1; i--) {\n    const id = componentsOrder[i];\n    const [ref] = componentsMap.get(id) ?? [];\n    if (ref?.current?.focus?.()) {\n      // prevent default action as the event has transferred focus\n      event.preventDefault();\n      // Focus is set, so break the loop\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Checks if the provided element is a part of any of the registered messages\n *\n * @param element The candidate element\n * @returns true if is inside any of the registered messages\n */\nfunction isPartOfRegisteredMessages(element: HTMLElement) {\n  for (const [ref] of componentsMap.values()) {\n    if (ref.current?.contains(element)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Finds the index of the item in the array, if it does not exist returns the\n * default value instead\n *\n * @param arr The array to perform the search\n * @param search The item to be searched\n * @param defaultIndex The default value if the item is not found\n * @returns The index of the item or the default value\n */\nfunction indexOfOrDefaultTo<T>(arr: T[], search: T, defaultIndex = -1) {\n  const index = arr.indexOf(search);\n  if (index !== -1) return index;\n  return defaultIndex;\n}\n\n/**\n * Traverses through the priorFocusCache to fetch the last focused\n * element outside of the messages region.\n *\n * @param id The current focused message's ID\n * @returns The closest prior focused element, null if not found\n */\nfunction getClosestPriorFocusedElement(id: symbol) {\n  // F6 navigation cycles through messages in reverse order\n  // so to get the closest prior focused element we need to\n  // traverse in natural order from the current message\n  const index = componentsOrder.indexOf(id);\n  for (let i = index; i < componentsOrder.length; i++) {\n    if (priorFocusCache.has(componentsOrder[i])) {\n      return priorFocusCache.get(componentsOrder[i])!;\n    }\n  }\n\n  // No prior cache found, so return null\n  return null;\n}\n\n/**\n * Adds the component to the internal members.\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param ref A ref handle to the focusable component\n * @param callbacks Optional callbacks\n */\nfunction addComponent(\n  id: symbol,\n  ref: RefObject<FocusableComponentHandle>,\n  callbacks?: FocusableComponentCallbacks\n) {\n  componentsMap.set(id, [ref, callbacks]);\n  componentsOrder.push(id);\n}\n\n/**\n * Removes the component from the internal members\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction removeComponent(id: symbol) {\n  if (!componentsMap.has(id)) {\n    return;\n  }\n\n  componentsMap.delete(id);\n  componentsOrder.splice(componentsOrder.indexOf(id), 1);\n}\n\n/**\n * Clears the priorFocusCache of the specified component\n *\n * @param id The id of the component whose cache is to be cleared\n */\nfunction clearFocusCache(id: symbol) {\n  priorFocusCache.delete(id);\n}\n\n/**\n * Adds event listeners to the document element\n */\nfunction addDocumentListeners() {\n  // Add the events in capture phase, as we do not want this to be stopped by the elements\n  // in the DOM tree\n  document.documentElement.addEventListener('keydown', handleDocumentKeyDownCapture, true);\n  document.documentElement.addEventListener('blur', handleDocumentBlurCapture, true);\n  hasDocumentListener = true;\n}\n\n/**\n * Removes event listeners from the document element\n */\nfunction removeDocumentListeners() {\n  document.documentElement.removeEventListener('keydown', handleDocumentKeyDownCapture, true);\n  document.documentElement.removeEventListener('blur', handleDocumentBlurCapture, true);\n  hasDocumentListener = false;\n}\n\n/**\n * Registers a component for its focus to be managed.\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param ref A ref handle to the focusable component\n * @param callbacks Optional callbacks\n *\n * @returns An object focus event listener and keydown event listener\n */\nfunction register(\n  id: symbol,\n  ref: RefObject<FocusableComponentHandle>,\n  callbacks?: FocusableComponentCallbacks\n): FocusManagerHandlers {\n  if (!hasDocumentListener) {\n    addDocumentListeners();\n  }\n\n  addComponent(id, ref, callbacks);\n  return {\n    onfocusin: (event: FocusEvent) => handleComponentFocus(id, event),\n    onfocusout: (event: FocusEvent) => handleComponentBlur(id, event),\n    onKeyDown: (event: KeyboardEvent) => handleComponentKeyDown(id, event)\n  };\n}\n\n/**\n * Focuses the element which was focused prior to the passed component.\n * @param id A unique symbol that ids the component to be registered for managing focus\n * @param event The event that initiated the focus transfer. The event will be default prevented if the focus\n *              is transferred successfully.\n * @returns true, if focus is restored. false otherwise.\n */\nfunction togglePreviousFocus(id: symbol, event?: Event) {\n  const target = getClosestPriorFocusedElement(id);\n  if (target && document.body.contains(target)) {\n    (target as HTMLElement).focus();\n    // As the prior focus is restored, empty the focus cache\n    priorFocusCache.clear();\n    event?.preventDefault();\n    return true;\n  }\n\n  // Prior focused element does not exist or\n  // Element does not exist in DOM.\n  return false;\n}\n\n/**\n * Unregisters a component from focus management\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction unregister(id: symbol) {\n  removeComponent(id);\n  clearFocusCache(id);\n\n  if (hasDocumentListener && componentsMap.size === 0) {\n    // no component is registered, so remove the document listeners\n    removeDocumentListeners();\n  }\n}\n\n/**\n * Moves the priority of the component with the specified id\n *\n * @param id A unique symbol that ids the component to be registered for managing focus\n */\nfunction prioritize(id: symbol) {\n  if (!componentsMap.has(id)) {\n    // Do nothing if the component is not registered\n    return;\n  }\n\n  // Remove and add the component with the same ref\n  // to move it in the priority queue\n  const [ref, callbacks] = componentsMap.get(id)!;\n  removeComponent(id);\n  addComponent(id, ref, callbacks);\n}\n\n/**\n * The focus manager object\n */\nconst messagesFocusManager = {\n  prioritize,\n  register,\n  togglePreviousFocus,\n  unregister\n};\n\n/**\n * A custom hook that handles focus management for the messages component.\n * @param ref The custom ref handle for the component\n * @param callbacks Optional callbacks\n * @returns The handlers and a controller\n */\nexport function useMessageFocusManager(\n  ref: RefObject<FocusableComponentHandle>,\n  callbacks?: FocusableComponentCallbacks\n) {\n  const id = useRef(Symbol());\n  const focusManager = useRef(messagesFocusManager);\n  const [handlers, setHandlers] = useState<FocusManagerHandlers>({});\n  const controller = useMemo(\n    () => ({\n      prioritize: () => focusManager.current.prioritize(id.current),\n      restorePriorFocus: () => focusManager.current.togglePreviousFocus(id.current)\n    }),\n    [focusManager.current, id.current]\n  );\n\n  // Register handlers for focus management\n  useEffect(() => {\n    setHandlers(focusManager.current.register(id.current, ref, callbacks));\n    return () => focusManager.current.unregister(id.current);\n  }, []);\n\n  return {\n    handlers,\n    controller\n  };\n}\n"],"names":["componentsMap","Map","componentsOrder","priorFocusCache","priorFocusedElement","currentFocusedMessage","hasDocumentListener","handleDocumentKeyDownCapture","event","size","key","defaultPrevented","i","arr","search","defaultIndex","index","indexOf","indexOfOrDefaultTo","length","id","ref","_a","get","_c","_b","current","focus","call","preventDefault","cycleFocusThroughMessages","togglePreviousFocus","handleDocumentBlurCapture","target","handleComponentFocus","has","callbacks","element","values","contains","isPartOfRegisteredMessages","set","onFocus","addComponent","push","removeComponent","delete","splice","getClosestPriorFocusedElement","document","body","clear","messagesFocusManager","prioritize","register","documentElement","addEventListener","onfocusin","onfocusout","undefined","handleComponentBlur","onKeyDown","type","includes","handleComponentKeyDown","unregister","clearFocusCache","removeEventListener","useRef","Symbol","focusManager","handlers","setHandlers","useState","controller","useMemo","restorePriorFocus","useEffect"],"mappings":"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"}