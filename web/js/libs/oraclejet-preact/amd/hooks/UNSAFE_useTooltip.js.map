{"version":3,"file":"UNSAFE_useTooltip.js","sources":["../../../src/hooks/UNSAFE_useTooltip/useTooltipControlled.tsx","../../../src/hooks/UNSAFE_useTooltip/useTooltip.tsx"],"sourcesContent":["import { ComponentChild } from 'preact';\nimport { useState, useRef, useEffect } from 'preact/hooks';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport { useId } from '../UNSAFE_useId';\nimport { Floating, Offset, Placement, Coords, Rect } from '../../UNSAFE_Floating';\nimport { Layer } from '../../UNSAFE_Layer';\nimport { useHover } from '../UNSAFE_useHover';\nimport { useFocus } from '../UNSAFE_useFocus';\nimport { useTouch } from '../UNSAFE_useTouch';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport { stringLiteralArray } from '../../utils/UNSAFE_arrayUtils';\nimport { classNames } from '../../utils/UNSAFE_classNames';\n\nexport const positions = stringLiteralArray([\n  'start',\n  'top-start',\n  'top',\n  'top-end',\n  'end',\n  'bottom-end',\n  'bottom',\n  'bottom-start'\n]);\ntype Position = typeof positions[number];\n\nexport const anchorTos = stringLiteralArray(['element', 'pointer']);\ntype AnchorTo = typeof anchorTos[number];\n\ntype AnchorModel = { x: AnchorTo; y: AnchorTo };\n\ntype Props = {\n  text?: string;\n  variant?: 'tooltip' | 'datatip';\n  isOpen: boolean;\n  position?: Position;\n  isDisabled?: boolean;\n  anchor?: AnchorModel;\n  offset?: { mainAxis?: number; crossAxis?: number };\n  onToggle?: (details: { value: boolean }) => void;\n};\n\nconst styles = {\n  wrapper: cssProps`${{\n    display: 'flex',\n    alignItems: 'flex-end',\n    overflowY: 'hidden'\n  }}`,\n  base: cssProps`${{\n    color: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-text-color)',\n    backgroundColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-bg-color)',\n    paddingTop: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-vertical)',\n    paddingLeft: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-horizontal)',\n    paddingRight: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-horizontal)',\n    paddingBottom: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-vertical)',\n    borderRadius: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-radius)',\n    borderColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-color)',\n    fontSize: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-font-size)',\n    borderWidth: 'var(--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-width)',\n    borderStyle: 'solid'\n  }}`,\n  datatip: cssProps`${{\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-bg-color':\n      'rgb(var(--oj-c-PRIVATE-DO-NOT-USE-palette-neutral-rgb-0))',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-text-color':\n      'rgb(var(--oj-c-PRIVATE-DO-NOT-USE-palette-neutral-rgb-190))',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-padding-vertical':\n      'var(--oj-c-PRIVATE-DO-NOT-USE-core-spacing-2x)',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-radius':\n      'var(--oj-c-PRIVATE-DO-NOT-USE-core-border-radius-md)',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-border-color':\n      'rgba(var(--oj-c-PRIVATE-DO-NOT-USE-palette-neutral-rgb-190), 0.65)',\n    '--oj-c-PRIVATE-DO-NOT-USE-tooltip-font-size':\n      'var(--oj-c-PRIVATE-DO-NOT-USE-typography-body-xs-font-size)'\n  }}`\n};\n\nexport const useTooltipControlled = ({\n  text,\n  isOpen = false,\n  variant = 'tooltip',\n  position = 'bottom',\n  isDisabled = false,\n  anchor = { x: 'element', y: 'element' },\n  offset = { mainAxis: 0, crossAxis: 0 },\n  onToggle\n}: Props): {\n  tooltipContent: ComponentChild;\n  tooltipProps: Record<string, any>;\n} => {\n  // TODO - consider using useReducer to potentially simplify the implementation\n  // as part of a future improvement issue.\n  const [state, setState] = useState<\n    | 'hidden'\n    | 'mountTimeout'\n    | 'mountInitialize'\n    | 'mounting'\n    | 'mounted'\n    | 'unmountTimeout'\n    | 'unmounting'\n    | 'unmounted'\n  >(isOpen ? 'mounted' : 'hidden');\n  const isDatatip = variant === 'datatip';\n  const { hoverProps, isHover } = useHover({ isDisabled });\n  const { focusProps, isFocus } = useFocus({ isDisabled });\n  const { touchProps, isTouch } = useTouch({ isDisabled }); // TODO replace by useLongPress actionhook\n  const { hoverProps: popoverHoverProps, isHover: popoverIsHover } = useHover({ isDisabled });\n  const { touchProps: popoverTouchProps, isTouch: popoverIsTouch } = useTouch({ isDisabled });\n\n  const uniqueID = useId();\n  const isInitialRender = useRef(true);\n  const popoverRef = useRef<HTMLDivElement>(null);\n  const targetRef = useRef<HTMLElement | null>(null);\n  const coordsRef = useRef<Coords>({ x: 0, y: 0 });\n  const usedRef = anchor.x === 'element' && anchor.y === 'element' ? targetRef : coordsRef;\n  const delay = isDatatip ? 0 : 250;\n\n  const handleToggle = (isOpen: boolean) => {\n    setState(isOpen ? 'mountTimeout' : 'unmountTimeout');\n  };\n\n  useEffect(() => {\n    if (isInitialRender.current) {\n      isInitialRender.current = false;\n      return;\n    }\n    // No state updates in case focus or touch is already present\n    if (isFocus || isTouch) {\n      return;\n    }\n    handleToggle(isHover);\n  }, [isHover]);\n\n  useEffect(() => {\n    if (isInitialRender.current) {\n      isInitialRender.current = false;\n      return;\n    }\n    // No state updates in case hover or touch is already present\n    if (isHover || isTouch) {\n      return;\n    }\n    handleToggle(isFocus);\n  }, [isFocus]);\n\n  useEffect(() => {\n    if (isInitialRender.current) {\n      isInitialRender.current = false;\n      return;\n    }\n    // No state updates in case hover or focus is already present\n    if (isHover || isFocus) {\n      return;\n    }\n    handleToggle(isTouch);\n  }, [isTouch]);\n\n  useEffect(() => {\n    if (isInitialRender.current) {\n      isInitialRender.current = false;\n      return;\n    }\n    if (['mounted', 'unmountTimeout'].includes(state)) {\n      setState(popoverIsHover || popoverIsTouch ? 'mounted' : 'unmountTimeout');\n    }\n  }, [popoverIsHover, popoverIsTouch]);\n\n  useEffect(() => {\n    let timeout: ReturnType<typeof setTimeout>;\n    switch (state) {\n      case 'mountTimeout':\n        timeout = setTimeout(() => setState('mountInitialize'), delay);\n        break;\n      case 'mountInitialize':\n        setState('mounting');\n        onToggle?.({ value: true });\n        break;\n      case 'mounting':\n        setState('mounted');\n        break;\n      case 'unmountTimeout':\n        timeout = setTimeout(() => setState('unmounting'), delay);\n        break;\n      case 'unmounting':\n        setState('unmounted');\n        onToggle?.({ value: false });\n        break;\n    }\n    return () => clearTimeout(timeout);\n  }, [state]);\n\n  let actionableProps;\n  if (isDisabled) {\n    actionableProps = {};\n  } else {\n    const anchorInitProps = {\n      'aria-describedby': uniqueID,\n      onMouseEnter: (event: MouseEvent) => {\n        if (event.eventPhase === Event.AT_TARGET) {\n          targetRef.current = event.target as HTMLElement;\n        }\n      },\n      ...((anchor.x === 'pointer' || anchor.y === 'pointer') && {\n        onMouseMove: (event: MouseEvent) => {\n          if (event.eventPhase === Event.AT_TARGET) {\n            handleMouseMove(event);\n          }\n        }\n      }),\n      onFocus: (event: FocusEvent) => {\n        if (event.eventPhase === Event.AT_TARGET) {\n          targetRef.current = event.target as HTMLElement;\n        }\n      }\n    };\n    actionableProps = mergeProps(hoverProps, focusProps, touchProps, anchorInitProps);\n  }\n\n  // No need to process tooltip if disabled or no text is provided\n  // Include actionableProps to detect mouseenter in components\n  // hovered state won't update unless actionableProps are already present in the component when mouse enters\n  if (isDisabled || !text) {\n    return {\n      tooltipContent: null,\n      tooltipProps: actionableProps\n    };\n  }\n\n  // TODO JET-51708 useFloating.ts deepEqual compares function using toString method.\n  // We want it to evaluate false on each rerender so that we get the updated offset value.\n  const offsetFunctionLeft = ({ floating }: { floating: Rect }) => ({\n    mainAxis: offset?.mainAxis,\n    crossAxis: -floating.width - (offset.crossAxis || 0)\n  });\n  const offsetFunctionRight = ({ floating }: { floating: Rect }) => ({\n    mainAxis: offset?.mainAxis,\n    crossAxis: floating.width + (offset.crossAxis || 0)\n  });\n\n  const POSITIONS: {\n    [K in Position]: { placement: Placement; offsetValue: Offset };\n  } = {\n    top: {\n      placement: 'top',\n      offsetValue: offset\n    },\n    'top-end': {\n      placement: 'top-end',\n      offsetValue: offsetFunctionRight\n    },\n    end: {\n      placement: 'right',\n      offsetValue: offset\n    },\n    'bottom-end': {\n      placement: 'bottom-end',\n      offsetValue: offsetFunctionRight\n    },\n    bottom: {\n      placement: 'bottom',\n      offsetValue: offset\n    },\n    'bottom-start': {\n      placement: 'bottom-start',\n      offsetValue: offsetFunctionLeft\n    },\n    start: {\n      placement: 'left',\n      offsetValue: offset\n    },\n    'top-start': {\n      placement: 'top-start',\n      offsetValue: offsetFunctionLeft\n    }\n  };\n  const placements = POSITIONS[position];\n\n  const isHidden = state === 'hidden' || state === 'mountTimeout';\n  const popoverNode = popoverRef.current;\n  const transitionStyles = {\n    popoverOpacity: ['mounted', 'unmountTimeout'].includes(state)\n      ? isDatatip\n        ? '100%'\n        : '95%'\n      : '0%',\n    wrapperHeight: !isHidden && popoverNode ? `${popoverNode?.offsetHeight}px` : 'auto', // offsetHeight to include datatip border\n    popoverHeight:\n      state === 'mountInitialize'\n        ? 'none'\n        : ['mounted', 'unmountTimeout'].includes(state) && popoverNode\n        ? `${popoverNode?.offsetHeight}px`\n        : '0'\n  };\n\n  let mouseMoveTimeout: ReturnType<typeof setTimeout>;\n\n  const handleMouseMove = (event: MouseEvent) => {\n    clearTimeout(mouseMoveTimeout);\n    if (anchor.x === 'pointer' && anchor.y === 'pointer') {\n      // Display tooltip at the mouse position if both anchors are set to pointer\n      coordsRef.current = { x: event.clientX, y: event.clientY };\n      setState(state === 'mounted' ? 'mounting' : 'mounted');\n    } else if (anchor.x === 'pointer') {\n      // Tooltip maintains static offset from top side of the window\n      // if X anchor is set to 'pointer'\n      mouseMoveTimeout = setTimeout(() => {\n        const childrenY = targetRef?.current?.offsetHeight || 0;\n        const childrenTop = targetRef?.current?.offsetTop || 0;\n        const distance = childrenTop + childrenY;\n        coordsRef.current = { x: event.clientX, y: distance };\n        onToggle?.({ value: true });\n      }, delay);\n    } else if (anchor.y === 'pointer') {\n      // Tooltip maintains static offset from left side of window\n      // if Y anchor is set to 'pointer'\n      mouseMoveTimeout = setTimeout(() => {\n        const childrenX = targetRef?.current?.offsetWidth || 0;\n        const childrenLeft = targetRef?.current?.offsetLeft || 0;\n        const distance = childrenLeft + childrenX;\n        coordsRef.current = { x: distance, y: event.clientY };\n        onToggle?.({ value: true });\n      }, delay);\n    }\n  };\n\n  const handleTransitionEnd = (_: TransitionEvent) => {\n    if (state === 'mounting') {\n      setState('mounted');\n    }\n    if (state === 'unmounted') {\n      setState('hidden');\n    }\n  };\n\n  const renderContent = (\n    <Layer>\n      <Floating\n        anchorRef={usedRef}\n        placement={placements.placement}\n        offsetValue={placements.offsetValue}>\n        <div\n          id={uniqueID}\n          role=\"tooltip\"\n          {...popoverHoverProps}\n          {...popoverTouchProps}\n          class={styles.wrapper}\n          style={{\n            height: transitionStyles.wrapperHeight\n          }}>\n          <div\n            style={{\n              opacity: transitionStyles.popoverOpacity,\n              maxHeight: transitionStyles.popoverHeight,\n              transition:\n                'max-height 0.1s cubic-bezier(0.0, 0.0, 0.2, 1), opacity 0.1s cubic-bezier(0.0, 0.0, 0.2, 1)'\n            }}\n            onTransitionEnd={handleTransitionEnd}>\n            <div\n              ref={popoverRef}\n              class={classNames([styles.base, isDatatip ? styles[variant] : ''])}>\n              {text}\n            </div>\n          </div>\n        </div>\n      </Floating>\n    </Layer>\n  );\n\n  return {\n    tooltipContent: !isHidden && renderContent,\n    tooltipProps: actionableProps\n  };\n};\n","import { useState } from 'preact/hooks';\nimport { useTooltipControlled } from './useTooltipControlled';\n\ntype tooltipParameters = Parameters<typeof useTooltipControlled>[0];\n\ntype Props = {\n  text?: string;\n  position?: tooltipParameters['position'];\n  isDisabled?: boolean;\n  anchor?: tooltipParameters['anchor'];\n  offset?: { mainAxis?: number; crossAxis?: number };\n};\n\nexport const useTooltip = ({\n  text,\n  position = 'bottom',\n  isDisabled = false,\n  anchor = { x: 'element', y: 'element' },\n  offset = { mainAxis: 0, crossAxis: 0 }\n}: Props): ReturnType<typeof useTooltipControlled> => {\n  const [isOpen, setIsOpen] = useState<boolean>(false);\n  const disabled = isDisabled || !text;\n  const { tooltipContent, tooltipProps } = useTooltipControlled({\n    text,\n    isOpen,\n    position,\n    isDisabled: disabled,\n    offset,\n    anchor,\n    onToggle: ({ value }) => setIsOpen(value)\n  });\n\n  return {\n    tooltipContent,\n    tooltipProps\n  };\n};\n"],"names":["stringLiteralArray","styles","useTooltipControlled","text","isOpen","variant","position","isDisabled","anchor","x","y","offset","mainAxis","crossAxis","onToggle","state","setState","useState","isDatatip","hoverProps","isHover","useHover","focusProps","isFocus","useFocus","touchProps","isTouch","useTouch","popoverHoverProps","popoverIsHover","popoverTouchProps","popoverIsTouch","uniqueID","useId","isInitialRender","useRef","popoverRef","targetRef","coordsRef","handleToggle","actionableProps","current","timeout","setTimeout","delay","clearTimeout","event","eventPhase","Event","AT_TARGET","target","onMouseMove","onFocus","tooltipContent","tooltipProps","floating","width","placements","top","placement","offsetValue","offsetFunctionRight","end","bottom","offsetFunctionLeft","start","popoverNode","transitionStyles","includes","mouseMoveTimeout","handleMouseMove","clientX","clientY","childrenY","_a","offsetHeight","distance","_b","offsetTop","childrenX","offsetWidth","offsetLeft","transition","onTransitionEnd","_","children","_jsx","jsx","Object","assign","ref","class","classNames","base","isHidden","renderContent","setIsOpen","disabled","value"],"mappings":"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"}